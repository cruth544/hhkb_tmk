   1               		.file	"rn42.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.keyboard_leds,"ax",@progbits
  12               	keyboard_leds:
  13               	.LFB19:
  14               		.file 1 "rn42/rn42.c"
   1:rn42/rn42.c   **** #include <avr/io.h>
   2:rn42/rn42.c   **** #include "host.h"
   3:rn42/rn42.c   **** #include "host_driver.h"
   4:rn42/rn42.c   **** #include "serial.h"
   5:rn42/rn42.c   **** #include "rn42.h"
   6:rn42/rn42.c   **** #include "print.h"
   7:rn42/rn42.c   **** #include "timer.h"
   8:rn42/rn42.c   **** #include "wait.h"
   9:rn42/rn42.c   **** 
  10:rn42/rn42.c   **** 
  11:rn42/rn42.c   **** /* Host driver */
  12:rn42/rn42.c   **** static uint8_t keyboard_leds(void);
  13:rn42/rn42.c   **** static void send_keyboard(report_keyboard_t *report);
  14:rn42/rn42.c   **** static void send_mouse(report_mouse_t *report);
  15:rn42/rn42.c   **** static void send_system(uint16_t data);
  16:rn42/rn42.c   **** static void send_consumer(uint16_t data);
  17:rn42/rn42.c   **** 
  18:rn42/rn42.c   **** host_driver_t rn42_driver = {
  19:rn42/rn42.c   ****     keyboard_leds,
  20:rn42/rn42.c   ****     send_keyboard,
  21:rn42/rn42.c   ****     send_mouse,
  22:rn42/rn42.c   ****     send_system,
  23:rn42/rn42.c   ****     send_consumer
  24:rn42/rn42.c   **** };
  25:rn42/rn42.c   **** 
  26:rn42/rn42.c   **** 
  27:rn42/rn42.c   **** void rn42_init(void)
  28:rn42/rn42.c   **** {
  29:rn42/rn42.c   ****     // JTAG disable for PORT F. write JTD bit twice within four cycles.
  30:rn42/rn42.c   ****     MCUCR |= (1<<JTD);
  31:rn42/rn42.c   ****     MCUCR |= (1<<JTD);
  32:rn42/rn42.c   **** 
  33:rn42/rn42.c   ****     // PF7: BT connection control(high: connect, low: disconnect)
  34:rn42/rn42.c   ****     rn42_autoconnect();
  35:rn42/rn42.c   **** 
  36:rn42/rn42.c   ****     // PF6: linked(input without pull-up)
  37:rn42/rn42.c   ****     DDRF  &= ~(1<<6);
  38:rn42/rn42.c   ****     PORTF |=  (1<<6);
  39:rn42/rn42.c   **** 
  40:rn42/rn42.c   ****     // PF1: RTS(low: allowed to send, high: not allowed)
  41:rn42/rn42.c   ****     DDRF &= ~(1<<1);
  42:rn42/rn42.c   ****     PORTF &= ~(1<<1);
  43:rn42/rn42.c   **** 
  44:rn42/rn42.c   ****     // PD5: CTS(low: allow to send, high:not allow)
  45:rn42/rn42.c   ****     DDRD |= (1<<5);
  46:rn42/rn42.c   ****     PORTD &= ~(1<<5);
  47:rn42/rn42.c   **** 
  48:rn42/rn42.c   ****     serial_init();
  49:rn42/rn42.c   **** }
  50:rn42/rn42.c   **** 
  51:rn42/rn42.c   **** int16_t rn42_getc(void)
  52:rn42/rn42.c   **** {
  53:rn42/rn42.c   ****     return serial_recv2();
  54:rn42/rn42.c   **** }
  55:rn42/rn42.c   **** 
  56:rn42/rn42.c   **** const char *rn42_gets(uint16_t timeout)
  57:rn42/rn42.c   **** {
  58:rn42/rn42.c   ****     static char s[24];
  59:rn42/rn42.c   ****     uint16_t t = timer_read();
  60:rn42/rn42.c   ****     uint8_t i = 0;
  61:rn42/rn42.c   ****     int16_t c;
  62:rn42/rn42.c   ****     while (i < 23 && timer_elapsed(t) < timeout) {
  63:rn42/rn42.c   ****         if ((c = rn42_getc()) != -1) {
  64:rn42/rn42.c   ****             if ((char)c == '\r') continue;
  65:rn42/rn42.c   ****             if ((char)c == '\n') break;
  66:rn42/rn42.c   ****             s[i++] = c;
  67:rn42/rn42.c   ****         }
  68:rn42/rn42.c   ****     }
  69:rn42/rn42.c   ****     s[i] = '\0';
  70:rn42/rn42.c   ****     return s;
  71:rn42/rn42.c   **** }
  72:rn42/rn42.c   **** 
  73:rn42/rn42.c   **** void rn42_putc(uint8_t c)
  74:rn42/rn42.c   **** {
  75:rn42/rn42.c   ****     serial_send(c);
  76:rn42/rn42.c   **** }
  77:rn42/rn42.c   **** 
  78:rn42/rn42.c   **** void rn42_puts(char *s)
  79:rn42/rn42.c   **** {
  80:rn42/rn42.c   ****     while (*s)
  81:rn42/rn42.c   **** 	serial_send(*s++);
  82:rn42/rn42.c   **** }
  83:rn42/rn42.c   **** 
  84:rn42/rn42.c   **** bool rn42_autoconnecting(void)
  85:rn42/rn42.c   **** {
  86:rn42/rn42.c   ****     // GPIO6 for control connection(high: auto connect, low: disconnect)
  87:rn42/rn42.c   ****     // Note that this needs config: SM,4(Auto-Connect DTR Mode)
  88:rn42/rn42.c   ****     return (PORTF & (1<<7) ? true : false);
  89:rn42/rn42.c   **** }
  90:rn42/rn42.c   **** 
  91:rn42/rn42.c   **** void rn42_autoconnect(void)
  92:rn42/rn42.c   **** {
  93:rn42/rn42.c   ****     // hi to auto connect
  94:rn42/rn42.c   ****     DDRF |= (1<<7);
  95:rn42/rn42.c   ****     PORTF |= (1<<7);
  96:rn42/rn42.c   **** }
  97:rn42/rn42.c   **** 
  98:rn42/rn42.c   **** void rn42_disconnect(void)
  99:rn42/rn42.c   **** {
 100:rn42/rn42.c   ****     // low to disconnect
 101:rn42/rn42.c   ****     DDRF |= (1<<7);
 102:rn42/rn42.c   ****     PORTF &= ~(1<<7);
 103:rn42/rn42.c   **** }
 104:rn42/rn42.c   **** 
 105:rn42/rn42.c   **** bool rn42_rts(void)
 106:rn42/rn42.c   **** {
 107:rn42/rn42.c   ****     // low when RN-42 is powered and ready to receive
 108:rn42/rn42.c   ****     return PINF&(1<<1);
 109:rn42/rn42.c   **** }
 110:rn42/rn42.c   **** 
 111:rn42/rn42.c   **** void rn42_cts_hi(void)
 112:rn42/rn42.c   **** {
 113:rn42/rn42.c   ****     // not allow to send
 114:rn42/rn42.c   ****     PORTD |= (1<<5);
 115:rn42/rn42.c   **** }
 116:rn42/rn42.c   **** 
 117:rn42/rn42.c   **** void rn42_cts_lo(void)
 118:rn42/rn42.c   **** {
 119:rn42/rn42.c   ****     // allow to send
 120:rn42/rn42.c   ****     PORTD &= ~(1<<5);
 121:rn42/rn42.c   **** }
 122:rn42/rn42.c   **** 
 123:rn42/rn42.c   **** bool rn42_linked(void)
 124:rn42/rn42.c   **** {
 125:rn42/rn42.c   ****     // RN-42 GPIO2
 126:rn42/rn42.c   ****     //   Hi-Z:  Not powered
 127:rn42/rn42.c   ****     //   High:  Linked
 128:rn42/rn42.c   ****     //   Low:   Connecting
 129:rn42/rn42.c   ****     return PINF&(1<<6);
 130:rn42/rn42.c   **** }
 131:rn42/rn42.c   **** 
 132:rn42/rn42.c   **** 
 133:rn42/rn42.c   **** static uint8_t leds = 0;
 134:rn42/rn42.c   **** static uint8_t keyboard_leds(void) { return leds; }
  15               		.loc 1 134 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               		.loc 1 134 0
  22 0000 8091 0000 		lds r24,leds
  23 0004 0895      		ret
  24               		.cfi_endproc
  25               	.LFE19:
  27               		.section	.text.send_system,"ax",@progbits
  29               	send_system:
  30               	.LFB26:
 135:rn42/rn42.c   **** void rn42_set_leds(uint8_t l) { leds = l; }
 136:rn42/rn42.c   **** 
 137:rn42/rn42.c   **** 
 138:rn42/rn42.c   **** void rn42_send_str(const char *str)
 139:rn42/rn42.c   **** {
 140:rn42/rn42.c   ****     uint8_t c;
 141:rn42/rn42.c   ****     while ((c = pgm_read_byte(str++)))
 142:rn42/rn42.c   ****         rn42_putc(c);
 143:rn42/rn42.c   **** }
 144:rn42/rn42.c   **** 
 145:rn42/rn42.c   **** const char *rn42_send_command(const char *cmd)
 146:rn42/rn42.c   **** {
 147:rn42/rn42.c   ****     static const char *s;
 148:rn42/rn42.c   ****     rn42_send_str(cmd);
 149:rn42/rn42.c   ****     wait_ms(500);
 150:rn42/rn42.c   ****     s = rn42_gets(100);
 151:rn42/rn42.c   ****     xprintf("%s\r\n", s);
 152:rn42/rn42.c   ****     rn42_print_response();
 153:rn42/rn42.c   ****     return s;
 154:rn42/rn42.c   **** }
 155:rn42/rn42.c   **** 
 156:rn42/rn42.c   **** void rn42_print_response(void)
 157:rn42/rn42.c   **** {
 158:rn42/rn42.c   ****     int16_t c;
 159:rn42/rn42.c   ****     while ((c = rn42_getc()) != -1) {
 160:rn42/rn42.c   ****         xprintf("%c", c);
 161:rn42/rn42.c   ****     }
 162:rn42/rn42.c   **** }
 163:rn42/rn42.c   **** 
 164:rn42/rn42.c   **** 
 165:rn42/rn42.c   **** static void send_keyboard(report_keyboard_t *report)
 166:rn42/rn42.c   **** {
 167:rn42/rn42.c   ****     // wake from deep sleep
 168:rn42/rn42.c   **** /*
 169:rn42/rn42.c   ****     PORTD |= (1<<5);    // high
 170:rn42/rn42.c   ****     wait_ms(5);
 171:rn42/rn42.c   ****     PORTD &= ~(1<<5);   // low
 172:rn42/rn42.c   **** */
 173:rn42/rn42.c   **** 
 174:rn42/rn42.c   ****     serial_send(0xFD);  // Raw report mode
 175:rn42/rn42.c   ****     serial_send(9);     // length
 176:rn42/rn42.c   ****     serial_send(1);     // descriptor type
 177:rn42/rn42.c   ****     serial_send(report->mods);
 178:rn42/rn42.c   ****     serial_send(0x00);
 179:rn42/rn42.c   ****     serial_send(report->keys[0]);
 180:rn42/rn42.c   ****     serial_send(report->keys[1]);
 181:rn42/rn42.c   ****     serial_send(report->keys[2]);
 182:rn42/rn42.c   ****     serial_send(report->keys[3]);
 183:rn42/rn42.c   ****     serial_send(report->keys[4]);
 184:rn42/rn42.c   ****     serial_send(report->keys[5]);
 185:rn42/rn42.c   **** }
 186:rn42/rn42.c   **** 
 187:rn42/rn42.c   **** static void send_mouse(report_mouse_t *report)
 188:rn42/rn42.c   **** {
 189:rn42/rn42.c   ****     // wake from deep sleep
 190:rn42/rn42.c   **** /*
 191:rn42/rn42.c   ****     PORTD |= (1<<5);    // high
 192:rn42/rn42.c   ****     wait_ms(5);
 193:rn42/rn42.c   ****     PORTD &= ~(1<<5);   // low
 194:rn42/rn42.c   **** */
 195:rn42/rn42.c   **** 
 196:rn42/rn42.c   ****     serial_send(0xFD);  // Raw report mode
 197:rn42/rn42.c   ****     serial_send(5);     // length
 198:rn42/rn42.c   ****     serial_send(2);     // descriptor type
 199:rn42/rn42.c   ****     serial_send(report->buttons);
 200:rn42/rn42.c   ****     serial_send(report->x);
 201:rn42/rn42.c   ****     serial_send(report->y);
 202:rn42/rn42.c   ****     serial_send(report->v);
 203:rn42/rn42.c   **** }
 204:rn42/rn42.c   **** 
 205:rn42/rn42.c   **** static void send_system(uint16_t data)
 206:rn42/rn42.c   **** {
  31               		.loc 1 206 0
  32               		.cfi_startproc
  33               	.LVL0:
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 0 */
  37               	.L__stack_usage = 0
  38 0000 0895      		ret
  39               		.cfi_endproc
  40               	.LFE26:
  42               		.section	.text.config_keyboard_leds,"ax",@progbits
  44               	config_keyboard_leds:
  45               	.LFB29:
 207:rn42/rn42.c   ****     // Table 5-6 of RN-BT-DATA-UB
 208:rn42/rn42.c   ****     // 81,82,83 scan codes can be used?
 209:rn42/rn42.c   **** }
 210:rn42/rn42.c   **** 
 211:rn42/rn42.c   **** 
 212:rn42/rn42.c   **** static uint16_t usage2bits(uint16_t usage)
 213:rn42/rn42.c   **** {
 214:rn42/rn42.c   ****     switch (usage) {
 215:rn42/rn42.c   ****         case APPCONTROL_HOME:         return 0x01;
 216:rn42/rn42.c   ****         case APPLAUNCH_EMAIL:         return 0x02;
 217:rn42/rn42.c   ****         case APPCONTROL_SEARCH:       return 0x04;
 218:rn42/rn42.c   ****         //case AL_KBD_LAYOUT:         return 0x08;  // Apple virtual keybaord toggle
 219:rn42/rn42.c   ****         case AUDIO_VOL_UP:            return 0x10;
 220:rn42/rn42.c   ****         case AUDIO_VOL_DOWN:          return 0x20;
 221:rn42/rn42.c   ****         case AUDIO_MUTE:              return 0x40;
 222:rn42/rn42.c   ****         case TRANSPORT_PLAY_PAUSE:    return 0x80;
 223:rn42/rn42.c   ****         case TRANSPORT_NEXT_TRACK:    return 0x100;
 224:rn42/rn42.c   ****         case TRANSPORT_PREV_TRACK:    return 0x200;
 225:rn42/rn42.c   ****         case TRANSPORT_STOP:          return 0x400;
 226:rn42/rn42.c   ****         case TRANSPORT_STOP_EJECT:    return 0x800;
 227:rn42/rn42.c   ****         case TRANSPORT_FAST_FORWARD:  return 0x1000;
 228:rn42/rn42.c   ****         case TRANSPORT_REWIND:        return 0x2000;
 229:rn42/rn42.c   ****         //case return 0x4000;   // Stop/eject
 230:rn42/rn42.c   ****         //case return 0x8000;   // Internet browser
 231:rn42/rn42.c   ****     };
 232:rn42/rn42.c   ****     return 0;
 233:rn42/rn42.c   **** }
 234:rn42/rn42.c   **** 
 235:rn42/rn42.c   **** static void send_consumer(uint16_t data)
 236:rn42/rn42.c   **** {
 237:rn42/rn42.c   ****     uint16_t bits = usage2bits(data);
 238:rn42/rn42.c   ****     serial_send(0xFD);  // Raw report mode
 239:rn42/rn42.c   ****     serial_send(3);     // length
 240:rn42/rn42.c   ****     serial_send(3);     // descriptor type
 241:rn42/rn42.c   ****     serial_send(bits&0xFF);
 242:rn42/rn42.c   ****     serial_send((bits>>8)&0xFF);
 243:rn42/rn42.c   **** }
 244:rn42/rn42.c   **** 
 245:rn42/rn42.c   **** 
 246:rn42/rn42.c   **** /* Null driver for config_mode */
 247:rn42/rn42.c   **** static uint8_t config_keyboard_leds(void);
 248:rn42/rn42.c   **** static void config_send_keyboard(report_keyboard_t *report);
 249:rn42/rn42.c   **** static void config_send_mouse(report_mouse_t *report);
 250:rn42/rn42.c   **** static void config_send_system(uint16_t data);
 251:rn42/rn42.c   **** static void config_send_consumer(uint16_t data);
 252:rn42/rn42.c   **** 
 253:rn42/rn42.c   **** host_driver_t rn42_config_driver = {
 254:rn42/rn42.c   ****     config_keyboard_leds,
 255:rn42/rn42.c   ****     config_send_keyboard,
 256:rn42/rn42.c   ****     config_send_mouse,
 257:rn42/rn42.c   ****     config_send_system,
 258:rn42/rn42.c   ****     config_send_consumer
 259:rn42/rn42.c   **** };
 260:rn42/rn42.c   **** 
 261:rn42/rn42.c   **** static uint8_t config_keyboard_leds(void) { return leds; }
  46               		.loc 1 261 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  52               		.loc 1 261 0
  53 0000 8091 0000 		lds r24,leds
  54 0004 0895      		ret
  55               		.cfi_endproc
  56               	.LFE29:
  58               		.section	.text.config_send_keyboard,"ax",@progbits
  60               	config_send_keyboard:
  61               	.LFB30:
 262:rn42/rn42.c   **** static void config_send_keyboard(report_keyboard_t *report) {}
  62               		.loc 1 262 0
  63               		.cfi_startproc
  64               	.LVL1:
  65               	/* prologue: function */
  66               	/* frame size = 0 */
  67               	/* stack size = 0 */
  68               	.L__stack_usage = 0
  69 0000 0895      		ret
  70               		.cfi_endproc
  71               	.LFE30:
  73               		.section	.text.config_send_mouse,"ax",@progbits
  75               	config_send_mouse:
  76               	.LFB31:
 263:rn42/rn42.c   **** static void config_send_mouse(report_mouse_t *report) {}
  77               		.loc 1 263 0
  78               		.cfi_startproc
  79               	.LVL2:
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 0 */
  83               	.L__stack_usage = 0
  84 0000 0895      		ret
  85               		.cfi_endproc
  86               	.LFE31:
  88               		.section	.text.config_send_system,"ax",@progbits
  90               	config_send_system:
  91               	.LFB32:
 264:rn42/rn42.c   **** static void config_send_system(uint16_t data) {}
  92               		.loc 1 264 0
  93               		.cfi_startproc
  94               	.LVL3:
  95               	/* prologue: function */
  96               	/* frame size = 0 */
  97               	/* stack size = 0 */
  98               	.L__stack_usage = 0
  99 0000 0895      		ret
 100               		.cfi_endproc
 101               	.LFE32:
 103               		.section	.text.config_send_consumer,"ax",@progbits
 105               	config_send_consumer:
 106               	.LFB33:
 265:rn42/rn42.c   **** static void config_send_consumer(uint16_t data) {}
 107               		.loc 1 265 0
 108               		.cfi_startproc
 109               	.LVL4:
 110               	/* prologue: function */
 111               	/* frame size = 0 */
 112               	/* stack size = 0 */
 113               	.L__stack_usage = 0
 114 0000 0895      		ret
 115               		.cfi_endproc
 116               	.LFE33:
 118               		.section	.text.send_consumer,"ax",@progbits
 120               	send_consumer:
 121               	.LFB28:
 236:rn42/rn42.c   **** {
 122               		.loc 1 236 0
 123               		.cfi_startproc
 124               	.LVL5:
 236:rn42/rn42.c   **** {
 125               		.loc 1 236 0
 126 0000 CF93      		push r28
 127               	.LCFI0:
 128               		.cfi_def_cfa_offset 3
 129               		.cfi_offset 28, -2
 130 0002 DF93      		push r29
 131               	.LCFI1:
 132               		.cfi_def_cfa_offset 4
 133               		.cfi_offset 29, -3
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 2 */
 137               	.L__stack_usage = 2
 138               	.LVL6:
 139               	.LBB7:
 140               	.LBB8:
 214:rn42/rn42.c   ****     switch (usage) {
 141               		.loc 1 214 0
 142 0004 8D3C      		cpi r24,-51
 143 0006 9105      		cpc r25,__zero_reg__
 144 0008 01F0      		breq .L10
 145 000a 00F4      		brsh .L11
 146 000c 853B      		cpi r24,-75
 147 000e 9105      		cpc r25,__zero_reg__
 148 0010 01F0      		breq .L12
 149 0012 00F4      		brsh .L13
 150 0014 833B      		cpi r24,-77
 151 0016 9105      		cpc r25,__zero_reg__
 152 0018 01F0      		breq .L14
 153 001a 843B      		cpi r24,-76
 154 001c 9105      		cpc r25,__zero_reg__
 155 001e 01F4      		brne .L9
 228:rn42/rn42.c   ****         case TRANSPORT_REWIND:        return 0x2000;
 156               		.loc 1 228 0
 157 0020 D0E0      		ldi r29,0
 158 0022 C0E2      		ldi r28,lo8(32)
 159 0024 00C0      		rjmp .L25
 160               	.L13:
 214:rn42/rn42.c   ****     switch (usage) {
 161               		.loc 1 214 0
 162 0026 873B      		cpi r24,-73
 163 0028 9105      		cpc r25,__zero_reg__
 164 002a 01F0      		breq .L16
 165 002c 00F0      		brlo .L17
 166 002e 8C3C      		cpi r24,-52
 167 0030 9105      		cpc r25,__zero_reg__
 168 0032 01F4      		brne .L9
 226:rn42/rn42.c   ****         case TRANSPORT_STOP_EJECT:    return 0x800;
 169               		.loc 1 226 0
 170 0034 D0E0      		ldi r29,0
 171 0036 C8E0      		ldi r28,lo8(8)
 172 0038 00C0      		rjmp .L25
 173               	.L11:
 214:rn42/rn42.c   ****     switch (usage) {
 174               		.loc 1 214 0
 175 003a 8A3E      		cpi r24,-22
 176 003c 9105      		cpc r25,__zero_reg__
 177 003e 01F0      		breq .L19
 178 0040 00F4      		brsh .L20
 179 0042 823E      		cpi r24,-30
 180 0044 9105      		cpc r25,__zero_reg__
 181 0046 01F0      		breq .L21
 182 0048 893E      		cpi r24,-23
 183 004a 9105      		cpc r25,__zero_reg__
 184 004c 01F4      		brne .L9
 219:rn42/rn42.c   ****         case AUDIO_VOL_UP:            return 0x10;
 185               		.loc 1 219 0
 186 004e D0E1      		ldi r29,lo8(16)
 187 0050 00C0      		rjmp .L27
 188               	.L20:
 214:rn42/rn42.c   ****     switch (usage) {
 189               		.loc 1 214 0
 190 0052 8132      		cpi r24,33
 191 0054 22E0      		ldi r18,2
 192 0056 9207      		cpc r25,r18
 193 0058 01F0      		breq .L23
 194 005a 8332      		cpi r24,35
 195 005c 22E0      		ldi r18,2
 196 005e 9207      		cpc r25,r18
 197 0060 01F0      		breq .L24
 198 0062 8A38      		cpi r24,-118
 199 0064 9140      		sbci r25,1
 200 0066 01F4      		brne .L9
 201 0068 00C0      		rjmp .L29
 202               	.L24:
 215:rn42/rn42.c   ****         case APPCONTROL_HOME:         return 0x01;
 203               		.loc 1 215 0
 204 006a D1E0      		ldi r29,lo8(1)
 205 006c 00C0      		rjmp .L27
 206               	.L23:
 217:rn42/rn42.c   ****         case APPCONTROL_SEARCH:       return 0x04;
 207               		.loc 1 217 0
 208 006e D4E0      		ldi r29,lo8(4)
 209 0070 00C0      		rjmp .L27
 210               	.L19:
 220:rn42/rn42.c   ****         case AUDIO_VOL_DOWN:          return 0x20;
 211               		.loc 1 220 0
 212 0072 D0E2      		ldi r29,lo8(32)
 213 0074 00C0      		rjmp .L27
 214               	.L21:
 221:rn42/rn42.c   ****         case AUDIO_MUTE:              return 0x40;
 215               		.loc 1 221 0
 216 0076 D0E4      		ldi r29,lo8(64)
 217 0078 00C0      		rjmp .L27
 218               	.L10:
 222:rn42/rn42.c   ****         case TRANSPORT_PLAY_PAUSE:    return 0x80;
 219               		.loc 1 222 0
 220 007a D0E8      		ldi r29,lo8(-128)
 221 007c 00C0      		rjmp .L27
 222               	.L12:
 223:rn42/rn42.c   ****         case TRANSPORT_NEXT_TRACK:    return 0x100;
 223               		.loc 1 223 0
 224 007e D0E0      		ldi r29,0
 225 0080 C1E0      		ldi r28,lo8(1)
 226 0082 00C0      		rjmp .L25
 227               	.L17:
 224:rn42/rn42.c   ****         case TRANSPORT_PREV_TRACK:    return 0x200;
 228               		.loc 1 224 0
 229 0084 D0E0      		ldi r29,0
 230 0086 C2E0      		ldi r28,lo8(2)
 231 0088 00C0      		rjmp .L25
 232               	.L16:
 225:rn42/rn42.c   ****         case TRANSPORT_STOP:          return 0x400;
 233               		.loc 1 225 0
 234 008a D0E0      		ldi r29,0
 235 008c C4E0      		ldi r28,lo8(4)
 236 008e 00C0      		rjmp .L25
 237               	.L14:
 227:rn42/rn42.c   ****         case TRANSPORT_FAST_FORWARD:  return 0x1000;
 238               		.loc 1 227 0
 239 0090 D0E0      		ldi r29,0
 240 0092 C0E1      		ldi r28,lo8(16)
 241 0094 00C0      		rjmp .L25
 242               	.L9:
 232:rn42/rn42.c   ****     return 0;
 243               		.loc 1 232 0
 244 0096 D0E0      		ldi r29,0
 245 0098 00C0      		rjmp .L27
 246               	.L29:
 216:rn42/rn42.c   ****         case APPLAUNCH_EMAIL:         return 0x02;
 247               		.loc 1 216 0
 248 009a D2E0      		ldi r29,lo8(2)
 249               	.L27:
 250 009c C0E0      		ldi r28,0
 251               	.L25:
 252               	.LBE8:
 253               	.LBE7:
 238:rn42/rn42.c   ****     serial_send(0xFD);  // Raw report mode
 254               		.loc 1 238 0
 255 009e 8DEF      		ldi r24,lo8(-3)
 256               	.LVL7:
 257 00a0 0E94 0000 		call serial_send
 258               	.LVL8:
 239:rn42/rn42.c   ****     serial_send(3);     // length
 259               		.loc 1 239 0
 260 00a4 83E0      		ldi r24,lo8(3)
 261 00a6 0E94 0000 		call serial_send
 262               	.LVL9:
 240:rn42/rn42.c   ****     serial_send(3);     // descriptor type
 263               		.loc 1 240 0
 264 00aa 83E0      		ldi r24,lo8(3)
 265 00ac 0E94 0000 		call serial_send
 266               	.LVL10:
 241:rn42/rn42.c   ****     serial_send(bits&0xFF);
 267               		.loc 1 241 0
 268 00b0 8D2F      		mov r24,r29
 269 00b2 0E94 0000 		call serial_send
 270               	.LVL11:
 242:rn42/rn42.c   ****     serial_send((bits>>8)&0xFF);
 271               		.loc 1 242 0
 272 00b6 8C2F      		mov r24,r28
 273               	/* epilogue start */
 243:rn42/rn42.c   **** }
 274               		.loc 1 243 0
 275 00b8 DF91      		pop r29
 276 00ba CF91      		pop r28
 242:rn42/rn42.c   ****     serial_send((bits>>8)&0xFF);
 277               		.loc 1 242 0
 278 00bc 0C94 0000 		jmp serial_send
 279               	.LVL12:
 280               		.cfi_endproc
 281               	.LFE28:
 283               		.section	.text.send_mouse,"ax",@progbits
 285               	send_mouse:
 286               	.LFB25:
 188:rn42/rn42.c   **** {
 287               		.loc 1 188 0
 288               		.cfi_startproc
 289               	.LVL13:
 290 0000 CF93      		push r28
 291               	.LCFI2:
 292               		.cfi_def_cfa_offset 3
 293               		.cfi_offset 28, -2
 294 0002 DF93      		push r29
 295               	.LCFI3:
 296               		.cfi_def_cfa_offset 4
 297               		.cfi_offset 29, -3
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 2 */
 301               	.L__stack_usage = 2
 302 0004 EC01      		movw r28,r24
 196:rn42/rn42.c   ****     serial_send(0xFD);  // Raw report mode
 303               		.loc 1 196 0
 304 0006 8DEF      		ldi r24,lo8(-3)
 305               	.LVL14:
 306 0008 0E94 0000 		call serial_send
 307               	.LVL15:
 197:rn42/rn42.c   ****     serial_send(5);     // length
 308               		.loc 1 197 0
 309 000c 85E0      		ldi r24,lo8(5)
 310 000e 0E94 0000 		call serial_send
 311               	.LVL16:
 198:rn42/rn42.c   ****     serial_send(2);     // descriptor type
 312               		.loc 1 198 0
 313 0012 82E0      		ldi r24,lo8(2)
 314 0014 0E94 0000 		call serial_send
 315               	.LVL17:
 199:rn42/rn42.c   ****     serial_send(report->buttons);
 316               		.loc 1 199 0
 317 0018 8881      		ld r24,Y
 318 001a 0E94 0000 		call serial_send
 319               	.LVL18:
 200:rn42/rn42.c   ****     serial_send(report->x);
 320               		.loc 1 200 0
 321 001e 8981      		ldd r24,Y+1
 322 0020 0E94 0000 		call serial_send
 323               	.LVL19:
 201:rn42/rn42.c   ****     serial_send(report->y);
 324               		.loc 1 201 0
 325 0024 8A81      		ldd r24,Y+2
 326 0026 0E94 0000 		call serial_send
 327               	.LVL20:
 202:rn42/rn42.c   ****     serial_send(report->v);
 328               		.loc 1 202 0
 329 002a 8B81      		ldd r24,Y+3
 330               	/* epilogue start */
 203:rn42/rn42.c   **** }
 331               		.loc 1 203 0
 332 002c DF91      		pop r29
 333 002e CF91      		pop r28
 334               	.LVL21:
 202:rn42/rn42.c   ****     serial_send(report->v);
 335               		.loc 1 202 0
 336 0030 0C94 0000 		jmp serial_send
 337               	.LVL22:
 338               		.cfi_endproc
 339               	.LFE25:
 341               		.section	.text.send_keyboard,"ax",@progbits
 343               	send_keyboard:
 344               	.LFB24:
 166:rn42/rn42.c   **** {
 345               		.loc 1 166 0
 346               		.cfi_startproc
 347               	.LVL23:
 348 0000 CF93      		push r28
 349               	.LCFI4:
 350               		.cfi_def_cfa_offset 3
 351               		.cfi_offset 28, -2
 352 0002 DF93      		push r29
 353               	.LCFI5:
 354               		.cfi_def_cfa_offset 4
 355               		.cfi_offset 29, -3
 356               	/* prologue: function */
 357               	/* frame size = 0 */
 358               	/* stack size = 2 */
 359               	.L__stack_usage = 2
 360 0004 EC01      		movw r28,r24
 174:rn42/rn42.c   ****     serial_send(0xFD);  // Raw report mode
 361               		.loc 1 174 0
 362 0006 8DEF      		ldi r24,lo8(-3)
 363               	.LVL24:
 364 0008 0E94 0000 		call serial_send
 365               	.LVL25:
 175:rn42/rn42.c   ****     serial_send(9);     // length
 366               		.loc 1 175 0
 367 000c 89E0      		ldi r24,lo8(9)
 368 000e 0E94 0000 		call serial_send
 369               	.LVL26:
 176:rn42/rn42.c   ****     serial_send(1);     // descriptor type
 370               		.loc 1 176 0
 371 0012 81E0      		ldi r24,lo8(1)
 372 0014 0E94 0000 		call serial_send
 373               	.LVL27:
 177:rn42/rn42.c   ****     serial_send(report->mods);
 374               		.loc 1 177 0
 375 0018 8881      		ld r24,Y
 376 001a 0E94 0000 		call serial_send
 377               	.LVL28:
 178:rn42/rn42.c   ****     serial_send(0x00);
 378               		.loc 1 178 0
 379 001e 80E0      		ldi r24,0
 380 0020 0E94 0000 		call serial_send
 381               	.LVL29:
 179:rn42/rn42.c   ****     serial_send(report->keys[0]);
 382               		.loc 1 179 0
 383 0024 8A81      		ldd r24,Y+2
 384 0026 0E94 0000 		call serial_send
 385               	.LVL30:
 180:rn42/rn42.c   ****     serial_send(report->keys[1]);
 386               		.loc 1 180 0
 387 002a 8B81      		ldd r24,Y+3
 388 002c 0E94 0000 		call serial_send
 389               	.LVL31:
 181:rn42/rn42.c   ****     serial_send(report->keys[2]);
 390               		.loc 1 181 0
 391 0030 8C81      		ldd r24,Y+4
 392 0032 0E94 0000 		call serial_send
 393               	.LVL32:
 182:rn42/rn42.c   ****     serial_send(report->keys[3]);
 394               		.loc 1 182 0
 395 0036 8D81      		ldd r24,Y+5
 396 0038 0E94 0000 		call serial_send
 397               	.LVL33:
 183:rn42/rn42.c   ****     serial_send(report->keys[4]);
 398               		.loc 1 183 0
 399 003c 8E81      		ldd r24,Y+6
 400 003e 0E94 0000 		call serial_send
 401               	.LVL34:
 184:rn42/rn42.c   ****     serial_send(report->keys[5]);
 402               		.loc 1 184 0
 403 0042 8F81      		ldd r24,Y+7
 404               	/* epilogue start */
 185:rn42/rn42.c   **** }
 405               		.loc 1 185 0
 406 0044 DF91      		pop r29
 407 0046 CF91      		pop r28
 408               	.LVL35:
 184:rn42/rn42.c   ****     serial_send(report->keys[5]);
 409               		.loc 1 184 0
 410 0048 0C94 0000 		jmp serial_send
 411               	.LVL36:
 412               		.cfi_endproc
 413               	.LFE24:
 415               		.section	.text.rn42_getc,"ax",@progbits
 416               	.global	rn42_getc
 418               	rn42_getc:
 419               	.LFB8:
  52:rn42/rn42.c   **** {
 420               		.loc 1 52 0
 421               		.cfi_startproc
 422               	/* prologue: function */
 423               	/* frame size = 0 */
 424               	/* stack size = 0 */
 425               	.L__stack_usage = 0
  53:rn42/rn42.c   ****     return serial_recv2();
 426               		.loc 1 53 0
 427 0000 0C94 0000 		jmp serial_recv2
 428               	.LVL37:
 429               		.cfi_endproc
 430               	.LFE8:
 432               		.section	.text.rn42_gets,"ax",@progbits
 433               	.global	rn42_gets
 435               	rn42_gets:
 436               	.LFB9:
  57:rn42/rn42.c   **** {
 437               		.loc 1 57 0
 438               		.cfi_startproc
 439               	.LVL38:
 440 0000 FF92      		push r15
 441               	.LCFI6:
 442               		.cfi_def_cfa_offset 3
 443               		.cfi_offset 15, -2
 444 0002 0F93      		push r16
 445               	.LCFI7:
 446               		.cfi_def_cfa_offset 4
 447               		.cfi_offset 16, -3
 448 0004 1F93      		push r17
 449               	.LCFI8:
 450               		.cfi_def_cfa_offset 5
 451               		.cfi_offset 17, -4
 452 0006 CF93      		push r28
 453               	.LCFI9:
 454               		.cfi_def_cfa_offset 6
 455               		.cfi_offset 28, -5
 456 0008 DF93      		push r29
 457               	.LCFI10:
 458               		.cfi_def_cfa_offset 7
 459               		.cfi_offset 29, -6
 460               	/* prologue: function */
 461               	/* frame size = 0 */
 462               	/* stack size = 5 */
 463               	.L__stack_usage = 5
 464 000a EC01      		movw r28,r24
  59:rn42/rn42.c   ****     uint16_t t = timer_read();
 465               		.loc 1 59 0
 466 000c 0E94 0000 		call timer_read
 467               	.LVL39:
 468 0010 8C01      		movw r16,r24
 469               	.LVL40:
  60:rn42/rn42.c   ****     uint8_t i = 0;
 470               		.loc 1 60 0
 471 0012 F12C      		mov r15,__zero_reg__
 472               	.LVL41:
 473               	.L34:
  62:rn42/rn42.c   ****     while (i < 23 && timer_elapsed(t) < timeout) {
 474               		.loc 1 62 0 discriminator 2
 475 0014 C801      		movw r24,r16
 476 0016 0E94 0000 		call timer_elapsed
 477               	.LVL42:
 478 001a 8C17      		cp r24,r28
 479 001c 9D07      		cpc r25,r29
 480 001e 00F4      		brsh .L36
 481               	.LBB11:
 482               	.LBB12:
  53:rn42/rn42.c   ****     return serial_recv2();
 483               		.loc 1 53 0
 484 0020 0E94 0000 		call serial_recv2
 485               	.LVL43:
 486 0024 9C01      		movw r18,r24
 487               	.LBE12:
 488               	.LBE11:
  63:rn42/rn42.c   ****         if ((c = rn42_getc()) != -1) {
 489               		.loc 1 63 0
 490 0026 2F3F      		cpi r18,-1
 491 0028 8FEF      		ldi r24,-1
 492 002a 3807      		cpc r19,r24
 493 002c 01F0      		breq .L35
  64:rn42/rn42.c   ****             if ((char)c == '\r') continue;
 494               		.loc 1 64 0
 495 002e 2D30      		cpi r18,lo8(13)
 496 0030 01F0      		breq .L35
  65:rn42/rn42.c   ****             if ((char)c == '\n') break;
 497               		.loc 1 65 0
 498 0032 2A30      		cpi r18,lo8(10)
 499 0034 01F0      		breq .L36
 500               	.LVL44:
  66:rn42/rn42.c   ****             s[i++] = c;
 501               		.loc 1 66 0
 502 0036 AF2D      		mov r26,r15
 503 0038 B0E0      		ldi r27,0
 504 003a A050      		subi r26,lo8(-(s.2207))
 505 003c B040      		sbci r27,hi8(-(s.2207))
 506 003e 2C93      		st X,r18
 507 0040 F394      		inc r15
 508               	.LVL45:
 509               	.L35:
  62:rn42/rn42.c   ****     while (i < 23 && timer_elapsed(t) < timeout) {
 510               		.loc 1 62 0 discriminator 1
 511 0042 86E1      		ldi r24,lo8(22)
 512 0044 8F15      		cp r24,r15
 513 0046 00F4      		brsh .L34
 514               	.L36:
  69:rn42/rn42.c   ****     s[i] = '\0';
 515               		.loc 1 69 0
 516 0048 EF2D      		mov r30,r15
 517 004a F0E0      		ldi r31,0
 518 004c E050      		subi r30,lo8(-(s.2207))
 519 004e F040      		sbci r31,hi8(-(s.2207))
 520 0050 1082      		st Z,__zero_reg__
  71:rn42/rn42.c   **** }
 521               		.loc 1 71 0
 522 0052 80E0      		ldi r24,lo8(s.2207)
 523 0054 90E0      		ldi r25,hi8(s.2207)
 524               	/* epilogue start */
 525 0056 DF91      		pop r29
 526 0058 CF91      		pop r28
 527               	.LVL46:
 528 005a 1F91      		pop r17
 529 005c 0F91      		pop r16
 530               	.LVL47:
 531 005e FF90      		pop r15
 532               	.LVL48:
 533 0060 0895      		ret
 534               		.cfi_endproc
 535               	.LFE9:
 537               		.section	.text.rn42_putc,"ax",@progbits
 538               	.global	rn42_putc
 540               	rn42_putc:
 541               	.LFB10:
  74:rn42/rn42.c   **** {
 542               		.loc 1 74 0
 543               		.cfi_startproc
 544               	.LVL49:
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547               	/* stack size = 0 */
 548               	.L__stack_usage = 0
  75:rn42/rn42.c   ****     serial_send(c);
 549               		.loc 1 75 0
 550 0000 0C94 0000 		jmp serial_send
 551               	.LVL50:
 552               		.cfi_endproc
 553               	.LFE10:
 555               		.section	.text.rn42_puts,"ax",@progbits
 556               	.global	rn42_puts
 558               	rn42_puts:
 559               	.LFB11:
  79:rn42/rn42.c   **** {
 560               		.loc 1 79 0
 561               		.cfi_startproc
 562               	.LVL51:
 563 0000 CF93      		push r28
 564               	.LCFI11:
 565               		.cfi_def_cfa_offset 3
 566               		.cfi_offset 28, -2
 567 0002 DF93      		push r29
 568               	.LCFI12:
 569               		.cfi_def_cfa_offset 4
 570               		.cfi_offset 29, -3
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 2 */
 574               	.L__stack_usage = 2
 575 0004 EC01      		movw r28,r24
 576               	.LVL52:
 577               	.L49:
  80:rn42/rn42.c   ****     while (*s)
 578               		.loc 1 80 0 discriminator 1
 579 0006 8991      		ld r24,Y+
 580               	.LVL53:
 581 0008 8823      		tst r24
 582 000a 01F0      		breq .L51
 583               	.LVL54:
  81:rn42/rn42.c   **** 	serial_send(*s++);
 584               		.loc 1 81 0
 585 000c 0E94 0000 		call serial_send
 586               	.LVL55:
 587 0010 00C0      		rjmp .L49
 588               	.LVL56:
 589               	.L51:
 590               	/* epilogue start */
  82:rn42/rn42.c   **** }
 591               		.loc 1 82 0
 592 0012 DF91      		pop r29
 593 0014 CF91      		pop r28
 594               	.LVL57:
 595 0016 0895      		ret
 596               		.cfi_endproc
 597               	.LFE11:
 599               		.section	.text.rn42_autoconnecting,"ax",@progbits
 600               	.global	rn42_autoconnecting
 602               	rn42_autoconnecting:
 603               	.LFB12:
  85:rn42/rn42.c   **** {
 604               		.loc 1 85 0
 605               		.cfi_startproc
 606               	/* prologue: function */
 607               	/* frame size = 0 */
 608               	/* stack size = 0 */
 609               	.L__stack_usage = 0
  88:rn42/rn42.c   ****     return (PORTF & (1<<7) ? true : false);
 610               		.loc 1 88 0
 611 0000 81B3      		in r24,0x11
  89:rn42/rn42.c   **** }
 612               		.loc 1 89 0
 613 0002 881F      		rol r24
 614 0004 8827      		clr r24
 615 0006 881F      		rol r24
 616 0008 0895      		ret
 617               		.cfi_endproc
 618               	.LFE12:
 620               		.section	.text.rn42_autoconnect,"ax",@progbits
 621               	.global	rn42_autoconnect
 623               	rn42_autoconnect:
 624               	.LFB13:
  92:rn42/rn42.c   **** {
 625               		.loc 1 92 0
 626               		.cfi_startproc
 627               	/* prologue: function */
 628               	/* frame size = 0 */
 629               	/* stack size = 0 */
 630               	.L__stack_usage = 0
  94:rn42/rn42.c   ****     DDRF |= (1<<7);
 631               		.loc 1 94 0
 632 0000 879A      		sbi 0x10,7
  95:rn42/rn42.c   ****     PORTF |= (1<<7);
 633               		.loc 1 95 0
 634 0002 8F9A      		sbi 0x11,7
 635 0004 0895      		ret
 636               		.cfi_endproc
 637               	.LFE13:
 639               		.section	.text.rn42_init,"ax",@progbits
 640               	.global	rn42_init
 642               	rn42_init:
 643               	.LFB7:
  28:rn42/rn42.c   **** {
 644               		.loc 1 28 0
 645               		.cfi_startproc
 646               	/* prologue: function */
 647               	/* frame size = 0 */
 648               	/* stack size = 0 */
 649               	.L__stack_usage = 0
  30:rn42/rn42.c   ****     MCUCR |= (1<<JTD);
 650               		.loc 1 30 0
 651 0000 85B7      		in r24,0x35
 652 0002 8068      		ori r24,lo8(-128)
 653 0004 85BF      		out 0x35,r24
  31:rn42/rn42.c   ****     MCUCR |= (1<<JTD);
 654               		.loc 1 31 0
 655 0006 85B7      		in r24,0x35
 656 0008 8068      		ori r24,lo8(-128)
 657 000a 85BF      		out 0x35,r24
  34:rn42/rn42.c   ****     rn42_autoconnect();
 658               		.loc 1 34 0
 659 000c 0E94 0000 		call rn42_autoconnect
 660               	.LVL58:
  37:rn42/rn42.c   ****     DDRF  &= ~(1<<6);
 661               		.loc 1 37 0
 662 0010 8698      		cbi 0x10,6
  38:rn42/rn42.c   ****     PORTF |=  (1<<6);
 663               		.loc 1 38 0
 664 0012 8E9A      		sbi 0x11,6
  41:rn42/rn42.c   ****     DDRF &= ~(1<<1);
 665               		.loc 1 41 0
 666 0014 8198      		cbi 0x10,1
  42:rn42/rn42.c   ****     PORTF &= ~(1<<1);
 667               		.loc 1 42 0
 668 0016 8998      		cbi 0x11,1
  45:rn42/rn42.c   ****     DDRD |= (1<<5);
 669               		.loc 1 45 0
 670 0018 559A      		sbi 0xa,5
  46:rn42/rn42.c   ****     PORTD &= ~(1<<5);
 671               		.loc 1 46 0
 672 001a 5D98      		cbi 0xb,5
  48:rn42/rn42.c   ****     serial_init();
 673               		.loc 1 48 0
 674 001c 0C94 0000 		jmp serial_init
 675               	.LVL59:
 676               		.cfi_endproc
 677               	.LFE7:
 679               		.section	.text.rn42_disconnect,"ax",@progbits
 680               	.global	rn42_disconnect
 682               	rn42_disconnect:
 683               	.LFB14:
  99:rn42/rn42.c   **** {
 684               		.loc 1 99 0
 685               		.cfi_startproc
 686               	/* prologue: function */
 687               	/* frame size = 0 */
 688               	/* stack size = 0 */
 689               	.L__stack_usage = 0
 101:rn42/rn42.c   ****     DDRF |= (1<<7);
 690               		.loc 1 101 0
 691 0000 879A      		sbi 0x10,7
 102:rn42/rn42.c   ****     PORTF &= ~(1<<7);
 692               		.loc 1 102 0
 693 0002 8F98      		cbi 0x11,7
 694 0004 0895      		ret
 695               		.cfi_endproc
 696               	.LFE14:
 698               		.section	.text.rn42_rts,"ax",@progbits
 699               	.global	rn42_rts
 701               	rn42_rts:
 702               	.LFB15:
 106:rn42/rn42.c   **** {
 703               		.loc 1 106 0
 704               		.cfi_startproc
 705               	/* prologue: function */
 706               	/* frame size = 0 */
 707               	/* stack size = 0 */
 708               	.L__stack_usage = 0
 108:rn42/rn42.c   ****     return PINF&(1<<1);
 709               		.loc 1 108 0
 710 0000 8FB1      		in r24,0xf
 109:rn42/rn42.c   **** }
 711               		.loc 1 109 0
 712 0002 8695      		lsr r24
 713 0004 8170      		andi r24,1
 714 0006 0895      		ret
 715               		.cfi_endproc
 716               	.LFE15:
 718               		.section	.text.rn42_cts_hi,"ax",@progbits
 719               	.global	rn42_cts_hi
 721               	rn42_cts_hi:
 722               	.LFB16:
 112:rn42/rn42.c   **** {
 723               		.loc 1 112 0
 724               		.cfi_startproc
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 114:rn42/rn42.c   ****     PORTD |= (1<<5);
 729               		.loc 1 114 0
 730 0000 5D9A      		sbi 0xb,5
 731 0002 0895      		ret
 732               		.cfi_endproc
 733               	.LFE16:
 735               		.section	.text.rn42_cts_lo,"ax",@progbits
 736               	.global	rn42_cts_lo
 738               	rn42_cts_lo:
 739               	.LFB17:
 118:rn42/rn42.c   **** {
 740               		.loc 1 118 0
 741               		.cfi_startproc
 742               	/* prologue: function */
 743               	/* frame size = 0 */
 744               	/* stack size = 0 */
 745               	.L__stack_usage = 0
 120:rn42/rn42.c   ****     PORTD &= ~(1<<5);
 746               		.loc 1 120 0
 747 0000 5D98      		cbi 0xb,5
 748 0002 0895      		ret
 749               		.cfi_endproc
 750               	.LFE17:
 752               		.section	.text.rn42_linked,"ax",@progbits
 753               	.global	rn42_linked
 755               	rn42_linked:
 756               	.LFB18:
 124:rn42/rn42.c   **** {
 757               		.loc 1 124 0
 758               		.cfi_startproc
 759               	/* prologue: function */
 760               	/* frame size = 0 */
 761               	/* stack size = 0 */
 762               	.L__stack_usage = 0
 129:rn42/rn42.c   ****     return PINF&(1<<6);
 763               		.loc 1 129 0
 764 0000 8FB1      		in r24,0xf
 130:rn42/rn42.c   **** }
 765               		.loc 1 130 0
 766 0002 86FB      		bst r24,6
 767 0004 8827      		clr r24
 768 0006 80F9      		bld r24,0
 769 0008 0895      		ret
 770               		.cfi_endproc
 771               	.LFE18:
 773               		.section	.text.rn42_set_leds,"ax",@progbits
 774               	.global	rn42_set_leds
 776               	rn42_set_leds:
 777               	.LFB20:
 135:rn42/rn42.c   **** void rn42_set_leds(uint8_t l) { leds = l; }
 778               		.loc 1 135 0
 779               		.cfi_startproc
 780               	.LVL60:
 781               	/* prologue: function */
 782               	/* frame size = 0 */
 783               	/* stack size = 0 */
 784               	.L__stack_usage = 0
 135:rn42/rn42.c   **** void rn42_set_leds(uint8_t l) { leds = l; }
 785               		.loc 1 135 0
 786 0000 8093 0000 		sts leds,r24
 787 0004 0895      		ret
 788               		.cfi_endproc
 789               	.LFE20:
 791               		.section	.text.rn42_send_str,"ax",@progbits
 792               	.global	rn42_send_str
 794               	rn42_send_str:
 795               	.LFB21:
 139:rn42/rn42.c   **** {
 796               		.loc 1 139 0
 797               		.cfi_startproc
 798               	.LVL61:
 799 0000 CF93      		push r28
 800               	.LCFI13:
 801               		.cfi_def_cfa_offset 3
 802               		.cfi_offset 28, -2
 803 0002 DF93      		push r29
 804               	.LCFI14:
 805               		.cfi_def_cfa_offset 4
 806               		.cfi_offset 29, -3
 807               	/* prologue: function */
 808               	/* frame size = 0 */
 809               	/* stack size = 2 */
 810               	.L__stack_usage = 2
 811 0004 FC01      		movw r30,r24
 812               	.LVL62:
 813               	.L62:
 814               	.LBB16:
 141:rn42/rn42.c   ****     while ((c = pgm_read_byte(str++)))
 815               		.loc 1 141 0 discriminator 1
 816               	/* #APP */
 817               	 ;  141 "rn42/rn42.c" 1
 818 0006 8491      		lpm r24, Z
 819               		
 820               	 ;  0 "" 2
 821               	.LVL63:
 822               	/* #NOAPP */
 823 0008 EF01      		movw r28,r30
 824 000a 2196      		adiw r28,1
 825               	.LVL64:
 826               	.LBE16:
 827 000c 8823      		tst r24
 828 000e 01F0      		breq .L64
 829               	.LVL65:
 830               	.LBB17:
 831               	.LBB18:
  75:rn42/rn42.c   ****     serial_send(c);
 832               		.loc 1 75 0
 833 0010 0E94 0000 		call serial_send
 834               	.LVL66:
 835 0014 FE01      		movw r30,r28
 836 0016 00C0      		rjmp .L62
 837               	.LVL67:
 838               	.L64:
 839               	/* epilogue start */
 840               	.LBE18:
 841               	.LBE17:
 143:rn42/rn42.c   **** }
 842               		.loc 1 143 0
 843 0018 DF91      		pop r29
 844 001a CF91      		pop r28
 845               	.LVL68:
 846 001c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE21:
 850               		.section	.text.rn42_print_response,"ax",@progbits
 851               	.global	rn42_print_response
 853               	rn42_print_response:
 854               	.LFB23:
 157:rn42/rn42.c   **** {
 855               		.loc 1 157 0
 856               		.cfi_startproc
 857 0000 CF93      		push r28
 858               	.LCFI15:
 859               		.cfi_def_cfa_offset 3
 860               		.cfi_offset 28, -2
 861 0002 DF93      		push r29
 862               	.LCFI16:
 863               		.cfi_def_cfa_offset 4
 864               		.cfi_offset 29, -3
 865               	/* prologue: function */
 866               	/* frame size = 0 */
 867               	/* stack size = 2 */
 868               	.L__stack_usage = 2
 160:rn42/rn42.c   ****         xprintf("%c", c);
 869               		.loc 1 160 0
 870 0004 C0E0      		ldi r28,lo8(__c.2271)
 871 0006 D0E0      		ldi r29,hi8(__c.2271)
 872               	.L66:
 873               	.LBB22:
 874               	.LBB23:
  53:rn42/rn42.c   ****     return serial_recv2();
 875               		.loc 1 53 0 discriminator 1
 876 0008 0E94 0000 		call serial_recv2
 877               	.LVL69:
 878               	.LBE23:
 879               	.LBE22:
 159:rn42/rn42.c   ****     while ((c = rn42_getc()) != -1) {
 880               		.loc 1 159 0 discriminator 1
 881 000c 8F3F      		cpi r24,-1
 882 000e 2FEF      		ldi r18,-1
 883 0010 9207      		cpc r25,r18
 884 0012 01F0      		breq .L68
 160:rn42/rn42.c   ****         xprintf("%c", c);
 885               		.loc 1 160 0
 886 0014 9F93      		push r25
 887               	.LCFI17:
 888               		.cfi_def_cfa_offset 5
 889 0016 8F93      		push r24
 890               	.LCFI18:
 891               		.cfi_def_cfa_offset 6
 892 0018 DF93      		push r29
 893               	.LCFI19:
 894               		.cfi_def_cfa_offset 7
 895 001a CF93      		push r28
 896               	.LCFI20:
 897               		.cfi_def_cfa_offset 8
 898 001c 0E94 0000 		call __xprintf
 899               	.LVL70:
 900 0020 0F90      		pop __tmp_reg__
 901 0022 0F90      		pop __tmp_reg__
 902 0024 0F90      		pop __tmp_reg__
 903 0026 0F90      		pop __tmp_reg__
 904               	.LCFI21:
 905               		.cfi_def_cfa_offset 4
 906 0028 00C0      		rjmp .L66
 907               	.L68:
 908               	/* epilogue start */
 162:rn42/rn42.c   **** }
 909               		.loc 1 162 0
 910 002a DF91      		pop r29
 911 002c CF91      		pop r28
 912 002e 0895      		ret
 913               		.cfi_endproc
 914               	.LFE23:
 916               		.section	.text.rn42_send_command,"ax",@progbits
 917               	.global	rn42_send_command
 919               	rn42_send_command:
 920               	.LFB22:
 146:rn42/rn42.c   **** {
 921               		.loc 1 146 0
 922               		.cfi_startproc
 923               	.LVL71:
 924               	/* prologue: function */
 925               	/* frame size = 0 */
 926               	/* stack size = 0 */
 927               	.L__stack_usage = 0
 148:rn42/rn42.c   ****     rn42_send_str(cmd);
 928               		.loc 1 148 0
 929 0000 0E94 0000 		call rn42_send_str
 930               	.LVL72:
 931               	.LBB24:
 932               	.LBB25:
 933               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 934               		.loc 2 163 0
 935 0004 2FEF      		ldi r18,lo8(1599999)
 936 0006 89E6      		ldi r24,hi8(1599999)
 937 0008 98E1      		ldi r25,hlo8(1599999)
 938 000a 2150      		1: subi r18,1
 939 000c 8040      		sbci r24,0
 940 000e 9040      		sbci r25,0
 941 0010 01F4      		brne 1b
 942 0012 00C0      		rjmp .
 943 0014 0000      		nop
 944               	.LBE25:
 945               	.LBE24:
 150:rn42/rn42.c   ****     s = rn42_gets(100);
 946               		.loc 1 150 0
 947 0016 84E6      		ldi r24,lo8(100)
 948 0018 90E0      		ldi r25,0
 949 001a 0E94 0000 		call rn42_gets
 950               	.LVL73:
 951 001e 8093 0000 		sts s.2264,r24
 952 0022 9093 0000 		sts s.2264+1,r25
 151:rn42/rn42.c   ****     xprintf("%s\r\n", s);
 953               		.loc 1 151 0
 954 0026 9F93      		push r25
 955               	.LCFI22:
 956               		.cfi_def_cfa_offset 3
 957 0028 8F93      		push r24
 958               	.LCFI23:
 959               		.cfi_def_cfa_offset 4
 960 002a 80E0      		ldi r24,lo8(__c.2265)
 961 002c 90E0      		ldi r25,hi8(__c.2265)
 962 002e 9F93      		push r25
 963               	.LCFI24:
 964               		.cfi_def_cfa_offset 5
 965 0030 8F93      		push r24
 966               	.LCFI25:
 967               		.cfi_def_cfa_offset 6
 968 0032 0E94 0000 		call __xprintf
 969               	.LVL74:
 152:rn42/rn42.c   ****     rn42_print_response();
 970               		.loc 1 152 0
 971 0036 0E94 0000 		call rn42_print_response
 972               	.LVL75:
 153:rn42/rn42.c   ****     return s;
 973               		.loc 1 153 0
 974 003a 0F90      		pop __tmp_reg__
 975 003c 0F90      		pop __tmp_reg__
 976 003e 0F90      		pop __tmp_reg__
 977 0040 0F90      		pop __tmp_reg__
 978               	.LCFI26:
 979               		.cfi_def_cfa_offset 2
 154:rn42/rn42.c   **** }
 980               		.loc 1 154 0
 981 0042 8091 0000 		lds r24,s.2264
 982 0046 9091 0000 		lds r25,s.2264+1
 983 004a 0895      		ret
 984               		.cfi_endproc
 985               	.LFE22:
 987               		.section	.progmem.data.__c.2271,"a",@progbits
 990               	__c.2271:
 991 0000 2563 00   		.string	"%c"
 992               		.section	.progmem.data.__c.2265,"a",@progbits
 995               	__c.2265:
 996 0000 2573 0D0A 		.string	"%s\r\n"
 996      00
 997               		.section	.bss.s.2264,"aw",@nobits
 1000               	s.2264:
 1001 0000 0000      		.zero	2
 1002               		.section	.bss.s.2207,"aw",@nobits
 1005               	s.2207:
 1006 0000 0000 0000 		.zero	24
 1006      0000 0000 
 1006      0000 0000 
 1006      0000 0000 
 1006      0000 0000 
 1007               		.section	.bss.leds,"aw",@nobits
 1010               	leds:
 1011 0000 00        		.zero	1
 1012               	.global	rn42_config_driver
 1013               		.section	.data.rn42_config_driver,"aw",@progbits
 1016               	rn42_config_driver:
 1017 0000 0000      		.word	gs(config_keyboard_leds)
 1018 0002 0000      		.word	gs(config_send_keyboard)
 1019 0004 0000      		.word	gs(config_send_mouse)
 1020 0006 0000      		.word	gs(config_send_system)
 1021 0008 0000      		.word	gs(config_send_consumer)
 1022               	.global	rn42_driver
 1023               		.section	.data.rn42_driver,"aw",@progbits
 1026               	rn42_driver:
 1027 0000 0000      		.word	gs(keyboard_leds)
 1028 0002 0000      		.word	gs(send_keyboard)
 1029 0004 0000      		.word	gs(send_mouse)
 1030 0006 0000      		.word	gs(send_system)
 1031 0008 0000      		.word	gs(send_consumer)
 1032               		.text
 1033               	.Letext0:
 1034               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 1035               		.file 4 "./tmk_core/common/report.h"
 1036               		.file 5 "./tmk_core/common/host_driver.h"
 1037               		.file 6 "./tmk_core/protocol/serial.h"
 1038               		.file 7 "./tmk_core/common/timer.h"
 1039               		.file 8 "./tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 rn42.c
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:2      *ABS*:0000003e __SP_H__
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:3      *ABS*:0000003d __SP_L__
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:4      *ABS*:0000003f __SREG__
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:6      *ABS*:00000001 __zero_reg__
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:12     .text.keyboard_leds:00000000 keyboard_leds
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:1010   .bss.leds:00000000 leds
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:29     .text.send_system:00000000 send_system
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:44     .text.config_keyboard_leds:00000000 config_keyboard_leds
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:60     .text.config_send_keyboard:00000000 config_send_keyboard
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:75     .text.config_send_mouse:00000000 config_send_mouse
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:90     .text.config_send_system:00000000 config_send_system
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:105    .text.config_send_consumer:00000000 config_send_consumer
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:120    .text.send_consumer:00000000 send_consumer
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:285    .text.send_mouse:00000000 send_mouse
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:343    .text.send_keyboard:00000000 send_keyboard
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:418    .text.rn42_getc:00000000 rn42_getc
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:435    .text.rn42_gets:00000000 rn42_gets
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:1005   .bss.s.2207:00000000 s.2207
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:540    .text.rn42_putc:00000000 rn42_putc
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:558    .text.rn42_puts:00000000 rn42_puts
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:602    .text.rn42_autoconnecting:00000000 rn42_autoconnecting
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:623    .text.rn42_autoconnect:00000000 rn42_autoconnect
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:642    .text.rn42_init:00000000 rn42_init
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:682    .text.rn42_disconnect:00000000 rn42_disconnect
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:701    .text.rn42_rts:00000000 rn42_rts
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:721    .text.rn42_cts_hi:00000000 rn42_cts_hi
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:738    .text.rn42_cts_lo:00000000 rn42_cts_lo
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:755    .text.rn42_linked:00000000 rn42_linked
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:776    .text.rn42_set_leds:00000000 rn42_set_leds
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:794    .text.rn42_send_str:00000000 rn42_send_str
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:853    .text.rn42_print_response:00000000 rn42_print_response
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:990    .progmem.data.__c.2271:00000000 __c.2271
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:919    .text.rn42_send_command:00000000 rn42_send_command
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:1000   .bss.s.2264:00000000 s.2264
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:995    .progmem.data.__c.2265:00000000 __c.2265
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:1016   .data.rn42_config_driver:00000000 rn42_config_driver
/var/folders/60/7jfz_t4j1gl3nbdqv9nkvh7rr0y5vx/T//ccDowIxE.s:1026   .data.rn42_driver:00000000 rn42_driver

UNDEFINED SYMBOLS
serial_send
serial_recv2
timer_read
timer_elapsed
serial_init
__xprintf
__do_copy_data
__do_clear_bss
